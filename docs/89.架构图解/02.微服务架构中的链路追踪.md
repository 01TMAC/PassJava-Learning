# 在医院，我把「链路追踪」加到项目上了

从上周六 7 号到今天的 11 号，我都在医院，小孩因肺炎已经住院了，我白天和晚上的时间需要照顾娃，只能在娃睡觉的时候肝文了。

这篇主要是偏实战，如何把链路追踪 `Sleuth` + `Zipkin` 加到我的 Spring Cloud 《佳必过》开源项目上。

本篇知识点：

- 链路追踪基本原理
- 如何在项目中轻松加入链路追踪中间件
- 如何使用链路追踪排查问题。

## 1、为什么要用服务链路追踪？

`微服务`架构其实是一个`分布式`的架构，按照业务划分成了多个服务单元。

由于服务单元的`数量`是很多的，有可能几千个，而且业务也会更复杂，如果出现了错误和异常，很难去定位。

比如一个请求需要调用多个服务才能完成整个业务闭环，而内部服务的代码逻辑和业务逻辑比较复杂，假如某个服务出现了问题，是难以快速确定那个服务出问题的。

而如果我们加上了分布式链路追踪，去跟踪一个请求有哪些服务参与其中，参与的顺序是怎样的，这样我们就知道了每个请求的详细经过，即使出了问题也能快速定位。

链路追踪组件有 Twitter 的 Zipkin、Google 的 Dapper、阿里的 Eagleeye 等。本文主要讲解 Zipkin。

 ## 2、链路追踪的核心

Spring Cloud Sleuth 借鉴了 Dapper 的术语。

### 2.1 Span（跨度）

- 大白话：远程调用和 Span  `一对一`。
- 基本的工作单元，每次发送一个远程调用服务就会产生一个 Span。

- Span 是一个 64 位的唯一 ID。

### 2.2 Trace（跟踪）

- 大白话：一个 Trace 对应多个 Span，`一对多`。
- 它由一系列 Span 组成，树状结构。

- 64 位唯一 ID。
- 每次客户端访问微服务系统的 API 接口，可能中间会调用多个微服务，每次调用都会产生一个新的 Span，而多个 Span 组成了 Trace

### 2.3 Annotation（注解）

链路追踪系统定义了一些核心注解，用来定义一个请求的开始和结束。注解包括：

- `cs` - Client Sent：客户端发送一个请求，描述了这个调用的 `Span` 的开始时间。
- `cs` - Server Received：服务端获得请求并准备开始处理它，如果将其 `sr` 减去 `cs` 时间戳，即可得到网络传输时间。
- `ss` - Server Sent：服务端发送响应，请求处理完成的时间，`ss` 时间戳减去 sr 时间戳，即可得到服务器请求的时间。
- `cr` - Client Received：服务端接收响应，Span 的结束时间，如果 `cr` 的时间戳减去 `cs` 时间戳，即可得到一次微服务调用所消耗的时间，也就是一个 `Span` 的消耗的总时间。

### 2.4 链路追踪原理

假定三个微服务调用的链路如下：Service 1 调用 Service 2，Service 2 调用 Service 3 和 Service 4

![image-20201111171158484](02.微服务架构中的链路追踪.assets/image-20201111171158484.png)

那么



![img](02.微服务架构中的链路追踪.assets/6944619-23cecac667fc1c11.png)



