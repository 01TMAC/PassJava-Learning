# 曝光 | 分布式的50种坑，第一个就跪了！

消息队列

搜索引擎

缓存

数据库

分布式服务框架

分布式锁

高可用架构

运维

# 一、分布式消息队列的坑

## 1. 消息队列的坑之幂等性

### （1）幂等性概念

所谓幂等性就是无论多少次操作和第一次的操作结果一样。如果消息被多次消费，很有可能造成数据的不一致。而如果消息不可避免地被消费多次，如果我们开发人员能通过技术手段保证数据的前后一致性，那也是可以接受的，这让我想起了Java并发编程中的ABA问题，如果出现了[ABA问题]([用积木讲解ABA原理 | 老婆居然又听懂了！](https://juejin.im/post/6864945088721027079))，若能保证所有数据的前后一致性也能接受。

### （2）场景分析

RabbitMQ、RocketMQ、Kafka 消息队列中间件都有可能出现消息重复消费问题。这种问题并不是MQ自己保证的，而是需要开发人员来保证。

这几款消息队列中间都是是全球最牛的分布式消息队列，那肯定考虑到了消息的幂等性。我们以Kafka为例，看看Kafka是怎么保证消息队列的幂等性。

Kafka有一个`偏移量`的概念，代表着消息的序号，每条消息写到消息队列都会有一个偏移量，消费者消费了数据之后，每过一段固定的时间，就会把消费过的消息的偏移量提交一下，表示已经消费过了，下次消费就从偏移量后面开始消费。

>  坑：当消费完消息后，还没来得及提交偏移量，系统就被关机了，那么未提交偏移量的消息则会再次被消费。

如下图所示，队列中的数据A、B、C，对应的偏移量分别为100、101、102，都被消费者消费了，但是只有数据A的偏移量100提交成功，另外2个偏移量因系统重启而导致未及时提交。

![系统重启，偏移量未提交](http://cdn.jayh.club/blog/20200915/m1x9HjhMfAci.png?imageslim)

重启后，消费者又是拿偏移量 100 以后的数据，从偏移量 101 开始拿消息。所以数据 B 和数据 C 被重复消息。

如下图所示：

![重启后，重复消费消息](http://cdn.jayh.club/blog/20200915/sdI5WxXpOtgL.png?imageslim)

### （3）避坑指南

- 插入数据 场景
  - 每次插入数据时，先检查下数据库中是否有这条数据的主键id，如果有，则进行更新操作。
- 写 Redis 场景
  - Redis 的 Set操作天然幂等性，所以不用考虑 Redis 写数据的问题。
- 其他场景
  - 生产者发送每条数据时，增加一个全局唯一id，类似订单id。每次消费时，先去 Redis 查下是否有这个 id，如果没有，则进行正常处理消息，且将 id 存到 Redis。如果查到有这个id，说明之前消费过，则不要进行重复处理这条消息。

## 2.消息队列的坑之消息丢失