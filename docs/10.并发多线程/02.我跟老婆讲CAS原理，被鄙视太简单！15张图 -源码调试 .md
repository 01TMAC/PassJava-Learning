# 我跟老婆讲CAS原理，被鄙视太简单！ | 15张图 | 源码调试



夜黑风高的晚上，对话如下：

> 老婆：这画的图是啥意思，怎么还有三角形，四边形？
>
> 我：我在画CAS的原理，要不我跟你讲一遍？
>
> 老婆：好呀！

![请开始你的表演](http://cdn.jayh.club/blog/20200819/QrgY3SbBks2v.png?imageslim)

**案例：甲看见一个三角形积木，觉得不好看，想替换成五边形，但是乙想把积木替换成四边形。（前提条件，只能被替换一次）**

![案例](http://cdn.jayh.club/blog/20200818/OEvyi3KQE95G.png?imageslim)

甲比较鸡贼，想到了一个办法：“我把积木带到另外一个房间里面去替换，并上锁，就不会被别人打扰了。”（这里用到了`排他锁synchronized`）

乙觉得甲太不厚道：“房间上了锁，我进不去，我也看不见积木长啥样。（因上了锁，所以不能访问）”

![甲把房间锁住了](http://cdn.jayh.club/blog/20200818/zp0QVrLMySPu.png?imageslim)

于是甲、乙想到了另外一个办法：**谁先抢到积木，谁先替换，如果积木形状变了，则不允许其他人再次替换**。（`比较并替换CAS`）

于是他们就开始抢三角形积木：

   - 场景1：`甲抢到，替换成五边形，乙不能替换`

         - 假如甲先抢到了，积木还是三角形的，就把三角形替换成五边形了。

     ![甲先抢到，替换成五边形](http://cdn.jayh.club/blog/20200819/PrE1uNFiib8y.png?imageslim)

        - 乙后抢到，积木已经变为五边形了，乙就没机会替换了（因为甲、乙共一次替换机会）。

          ![mark](http://cdn.jayh.club/blog/20200818/leIc0y5ne6sO.png?imageslim)

     

- 场景2：`乙抢到未替换，甲替换成功`

  - 假如乙先抢到了，但是突然觉得三角形也挺好看的，没有替换，放下积木就走开了。

  - 然后甲抢到了积木，积木还是三角形的，想到乙没有替换，就把三角形替换成五边形了。

  ![乙抢到未替换，甲替换成功](http://cdn.jayh.club/blog/20200818/HzprJycWtrux.png?imageslim)

- 场景3：`乙抢到，替换成三角形，甲替换成五边形，ABA问题`
  - 假如乙先抢到了，但是觉得这个三角形是旧的，就换了另外一个一摸一样的三角形，只是积木比较新。
  - 然后甲抢到了积木，积木还是三角形的，想到乙没有替换，就把三角形替换成五边形了。

![乙抢到，替换成三角形，甲替换成五边形，ABA问题](http://cdn.jayh.club/blog/20200819/hC9pmBC6olW7.png?imageslim)

老婆听完后，觉得这三种场景都太简单了，**原来计算机这么简单，早知道我也去学计算机**。。。

![mark](http://cdn.jayh.club/blog/20200819/OuWkYsoSzQMe.png?imageslim)

被无情鄙视了，好在老婆居然听懂了，不知道大家听懂没？

回归正传，我们用计算机术语来讲下CAS的原理

# 一、CAS简介

CAS的全称：Compare-And-Swap（比较并交换）。比较变量的现在值与之前的值是否一致，若一致则替换，否则不替换。

CAS的作用：原子性更新变量值，保证线程安全。

CAS指令需要有三个操作数，变量的当前值（V），旧的预期值（A），准备设置的新值（B）。

CAS指令执行条件，当且仅当V=A时，处理器才会设置V=B，否则不执行更新。

CAS的返回指：V的之前值。

CAS处理过程：原子操作，执行期间不会被其他线程中断，线程安全。

# 二、能写几行代码说明下吗？

在上篇讲volatile时，讲到了如何使用原子整型类AtomicInteger来解决volatile的非原子性问题，保证多个线程执行num++的操作，最终执行的结果与单线程一致，输出结果为20000。

这次我们还是用AtomicInteger。

首先定义atomicInteger变量的初始值等于10，主内存中的值设置为10

```java
AtomicInteger atomicInteger = new AtomicInteger(10);
```

然后调用atomicInteger的CAS方法，先比较当前变量atomicInteger的值是否是10，如果是，则将变量的值设置为20

```java
atomicInteger.compareAndSet(10, 20);
```

设置成功，atomicInteger更新为20

当我们再次调用atomicInteger的CAS方法，先比较当前变量atomicInteger的值是否是10，如果是，则将变量的值设置为30

```java
atomicInteger.compareAndSet(10, 30);
```

设置失败，因atomicInteger的当前值为20，而比较值是10，**所以比较后，不相等，故不能进行更新**。

完整代码如下：

```java
package com.jackson0714.passjava.threads;
import java.util.concurrent.atomic.AtomicInteger;
/**
 演示CAS compareAndSet 比较并交换
 * @author: 悟空聊架构
 * @create: 2020-08-17
 */
public class CASDemo {
    public static void  main(String[] args) {
        AtomicInteger atomicInteger = new AtomicInteger(10);
        Boolean result1 = atomicInteger.compareAndSet(10,20);
        System.out.printf("当前atomicInteger变量的值:%d 比较结果%s\r\n", atomicInteger.get(), result1);
        Boolean result2 = atomicInteger.compareAndSet(10,30);
        System.out.printf("当前atomicInteger变量的值:%d, 比较结果%s\n" , atomicInteger.get(), result2);
    }
}
```

执行结果如下：

``` java
当前atomicInteger变量的值:20 比较结果true
当前atomicInteger变量的值:20, 比较结果false
```

![atomicInteger比较并交换的示例结果](http://cdn.jayh.club/blog/20200818/0bMPvFoWDkew.png?imageslim)



我们来对比看下原理图理解下上面代码的过程

- 第一步：线程1和线程2都有主内存中变量的拷贝，值都等于10

![mark](http://cdn.jayh.club/blog/20200819/XNCblvAWCr3w.png?imageslim)

- 第二步：线程1想要将值更新为20，先要将工作内存中的变量值与主内存中的变量进行比较，值都等于10，所以可以将主内存中的值替换成20

![mark](http://cdn.jayh.club/blog/20200819/lqJdYaKuklVl.png?imageslim)

- 第三步：线程1将主内存中的值替换成20，并将线程1中的工作内存中的副本更新为20

![mark](http://cdn.jayh.club/blog/20200819/i8Fv62wVF14v.png?imageslim)

- 第四步：线程2想要将变量更新为30，先要将线程2的工作内存中的值与主内存进行比较10不等于20，所以不能更新

![mark](http://cdn.jayh.club/blog/20200819/rpb0rUGrrHJk.png?imageslim)

- 第五步：线程2将工作内存的副本更新为与主内存一致：20

![mark](http://cdn.jayh.club/blog/20200819/11Np54tAbYk5.png?imageslim)

图画得非常棒！

![mark](http://cdn.jayh.club/blog/20200819/lvuvw7hiOURc.png?imageslim)

上述的场景和我们用Git代码管理工具是一样的，如果有人先提交了代码到develop分支，另外一个人想要改这个地方的代码，就得先pull develop分支，以免提交时提示冲突。

# 三、能讲下CAS底层原理吗？

## 源码调试

这里我们用atomicInteger的getAndIncrement()方法来讲解，这个方法里面涉及到了比较并替换的原理。

示例如下：

```java
public static void  main(String[] args) throws InterruptedException {
    AtomicInteger atomicInteger = new AtomicInteger(10);
    Thread.sleep(100);

    new Thread(() -> {
        atomicInteger.getAndIncrement();
    }, "aaa").start();

    atomicInteger.getAndIncrement();
}
```

- （1）首先需要开启IDEA的多线程调试模式

- （2）我们先打断点到17行，main线程执行到此行，子线程`aaa`还未执行自增操作。

![mark](http://cdn.jayh.club/blog/20200820/AQswHVY8bOw9.png?imageslim)

getAndIncrement方法会调用unsafe的`getAndAddInt`方法，

```java
public final int getAndIncrement() {
    return unsafe.getAndAddInt(this, valueOffset, 1);
}
```

- （3）在源码`getAndAddInt`方法的361行打上断点，main线程先执行到361行

  ```java
  public final int getAndAddInt(Object var1, long var2, int var4) {
  	int var5;
  	do {
  		var5 = this.getIntVolatile(var1, var2);
  	} while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));
  	return var5;
  }
  ```

  

  **源码解释：** <u>*划重点！！！*</u>

  - var1：当前对象，我们定义的atomicInteger
  - var2：当前对象的内存偏移量
  - var4：当前自增多少，默认为1，且不可设为其他值
  - var5：当前变量的值
  - `this.getIntVolatile(var1, var2)`：根据当前对象var1和对象的内存偏移量var2得到主内存中变量的值，赋值给var5，并在main线程的工作内存中存放一份var5的副本

![mark](http://cdn.jayh.club/blog/20200820/w4Pbmh2KKIBu.png?imageslim)

- （4）在362行打上断点，main线程继续执行一步

  - var5获取到主内存中的值为10

  ![mark](http://cdn.jayh.club/blog/20200820/Gt3sSVnLxYBa.png?imageslim)

- （5）切换到子线程aaa，还是在361行断点处，还未获取主内存的值

  ![mark](http://cdn.jayh.club/blog/20200820/SecJqDjHaLe9.png?imageslim)

- （6）子线程aaa继续执行一步，获取到var5的值等于10

![mark](http://cdn.jayh.club/blog/20200820/vdvPqeVu9sGF.png?imageslim)

（7）切换到main线程，进行比较并替换

```java
this.compareAndSwapInt(var1, var2, var5, var5 + var4)
```

var5=10，通过var1和var2获取到的值也是10，因为没有其他线程修改变量。compareAndSwapInt的源码我们后面再说。

所以比较后，发现变量没被其他线程修改，可以进行替换，替换值为var5+var4=11，变量值替换后为 11，也就是自增1。这行代码执行结果返回true（自增成功），退出do while循环。return值为变量更新前的值10。

![mark](http://cdn.jayh.club/blog/20200820/mqLNonLDmpm5.png?imageslim)

（8）切换到子线程aaa，进行比较并自增

因为此时aaa线程的var5=10，而主内存中的值已经更新为11了，所以比较后发现被其他线程修改了，不能进行替换，返回false，继续执行do while循环。

![mark](http://cdn.jayh.club/blog/20200820/5jzAQ3Xy22eL.png?imageslim)

- （9）子线程aaa继续执行，重新获取到的var=11

![mark](http://cdn.jayh.club/blog/20200820/yqEqKOH3JKFl.png?imageslim)

- （10）子线程aaa继续执行，进行比较和替换，结果为true

  因var5=11，主内存中的变量值也等于11，所以比较后相等，可以进行替换，替换值为var5+var4，结果为12，也就是自增1。退出循环，返回变量更新前的值var5=11。

![mark](http://cdn.jayh.club/blog/20200820/zx1kGeVHR834.png?imageslim)

至此，getAndIncrement方法的整个原子自增的逻辑就debug完了。所以可以得出结论：

> 先比较线程中的副本是否与主内存相等，相等则可以进行自增，并返回副本的值，若其他线程修改了主内存中的值，当前线程不能进行自增，需要重新获取主内存的值，然后再次判断是否与主内存中的值是否相等，以此往复。