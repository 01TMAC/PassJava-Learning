# 5000字 | 20张图庖丁解牛18种Queue

封面图

**本篇主要内容：** 



**帮你总结好的阻塞队列：**  

| 序号 | 名称                  | 类型   | 有界 | 线程安全 | 说明                                       |
| ---- | --------------------- | ------ | ---- | -------- | ------------------------------------------ |
| 1    | Queue<E>              | 接口   | /    | /        | 最上层队列接口                             |
| 2    | BlockingQueue<E>      | 接口   | /    | /        | 阻塞队列接口                               |
| 3    | BlockingDeque<E>      | 接口   | /    | /        | 双向阻塞队列接口                           |
| 4    | Deque<E>              | 接口   | /    | /        | 双向队列接口                               |
| 5    | TransferQueue<E>      | 接口   | /    | /        | 传输队列接口                               |
| 6    | AbstractQueue         | 抽象类 | /    | /        | 队列抽象类                                 |
| 7    | PriorityQueue         | 普通类 | N    | N        | 优先级队列类                               |
| 8    | ArrayDeque            | 普通类 | N    | N        | 数组双向队列类                             |
| 9    | LinkedList            | 普通类 | N    | N        | 链表对象类                                 |
| 10   | ConcurrentLinkedQueue | 普通类 | N    | Y        | 链表结构的线程安全的队列类                 |
| 11   | ConcurrentLinkedDeque | 普通类 | N    | Y        | 链表结构的线程安全的双向队列类             |
| 12   | ArrayBlockingQueue    | 普通类 | Y    | Y        | 数组结构的有界阻塞队列                     |
| 13   | LinkedBlockingQueue   | 普通类 | Y    | Y        | 链表结构的有界阻塞队列                     |
| 14   | LinkedBlockingDeque   | 普通类 | Y    | Y        | 链表结构的双向有界阻塞队列                 |
| 15   | LinkedTransferQueue   | 普通类 | N    | Y        | 链表组成的无界阻塞传输队列                 |
| 16   | SynchronousQueue      | 普通类 | Y    | Y        | 不存储元素的阻塞队列                       |
| 17   | PriorityBlockQueue    | 普通类 | N    | Y        | 支持优先级排序的无界阻塞队列               |
| 18   | DelayQueue            | 普通类 | N    | Y        | 支持优先级排序及延时获取元素的无界阻塞队列 |

ArrayBlockingQueue 默认不保证线程访问的公平性

## 一、队列自我介绍

![队列原理图](http://cdn.jayh.club/blog/20200906/CImqfwMGuSkt.png?imageslim)

我叫队列，无论现实生活中还是计算机的世界中，我都是一个很重要的角色哦~

我是一种数据结构，大家可以把我想象成一个数组，元素从我的一头进入、从另外一头出去，称为FIFO原则（先进先出原则）。

我还有两个亲兄弟：List（列表）、Set（集），他们都是Collection的儿子，我还有一个远房亲戚：Map（映射）。他们都是java.util包这个大家庭的成员哦~

**现实生活中的场景：** 

- 海底捞排号等位（先排号的优先进餐厅）
- 邮政员寄送信件（信箱是队列）

**计算机世界中的场景：**

- 消息队列 RabbitMQ
- UDP协议（接收端将消息存放在队列中，从队列中读取数据）

## 二、高屋建瓴，纵览全局

**18种队列分为三大类：** 接口、抽象类、普通类。

弄清楚下面的继承实现关系对后面理解18种队列有很大帮助。

![18个Queue的继承实现关系图](http://cdn.jayh.club/blog/20200906/EAHahXHxQAyM.png?imageslim)

- `Queue`接口**继承**`Collection`接口，`Collection`接口**继承** `Iterable`接口
- `BlockingQueue`接口、`Deque`接口 **继承** `Queue`接口
- `AbstractQueue`抽象类**实现**`Queue`接口
- `BlockingDeque`接口、`TransferQueue`接口**继承**`BlockingQueue`接口
- `LinkedBlockingDeque`类**实现**`BlockingDeque`接口
- `LinkedTransferQueue`类接口**实现**`TransferQueue`接口
- `LinkedList`类、`ArrayDeque`类、`ConcurrentLinkedDeque`类**实现** 了`Deque`接口
- `ArrayBlockingQueue`类、`LinkendBlockingQueue`类、`LinkedBlockingDeque`类、`LinkedTransferQueue`类、`SynchronousQueue`类、`PriorityBlockQueue`类、`DelayQueue类`**继承** 了`AbstractQueue`抽象类和**实现**了BlockingQueue接口
- `PriorityQueue`类和`ConcurrentLinkedQueue`类**继承** 了`AbstractQueue`抽象类

**注意：**

- Deque：全称Double-Ended queue，表示双端队列。
- 类实现接口，用implements
- 接口继承接口，用 extends
- 类继承类，用extends

## 三、庖丁解牛Queue接口

### 2.1 深入理解Queue接口的本质

- Queue接口是一种Collection，被设计用于处理之前临时保存在某处的元素。

- 除了基本的Collection操作之外，队列还提供了额外的插入、提取和检查操作。每一种操作都有两种形式：如果操作失败，则抛出一个异常；如果操作失败，则返回一个特殊值（null或false，取决于是什么操作）。

- 队列通常是以FIFO（先进先出）的方式排序元素，但是不是必须的。

- 只有优先级队列可以根据提供的比较器对元素进行排序或者是采用正常的排序。无论怎么排序，队列的头将通过调用remove()或poll()方法进行移除。在FIFO队列种，所有新的元素被插入到队尾。其他种类的队列可能使用不同的布局来存放元素。
- 每个Queue必须指定排序属性。

### 2.2 Queue接口的核心方法

总共有3组方法，每一组方法对应两个方法。如下图所示：

![Queue的核心方法](http://cdn.jayh.club/blog/20200906/2AsAXzoCGDnb.png?imageslim)

| 动作    | 抛异常    | 返回特殊值 |
| ------- | --------- | ---------- |
| Insert  | add(e)    | offer(e)   |
| Remove  | remove()  | poll       |
| Examine | element() | peek()     |

- （1）比如`添加（Insert）`元素的动作，会有两种方式：`add(e)`和`offer(e)`。如果调用add(e)方法时，添加失败，则会`抛异常`，而如果调用的是offer(e)方法失败时，则会`返回false`。offer方法用于异常是正常的情况下使用，比如在有界队列中，优先使用offer方法。假如队列满了，不能添加元素，offer方法返回false，这样我们就知道是队列满了，而不是去handle运行时抛出的异常。

- （2）同理，移除（Remove）元素的动作，队列为空时，remove方法抛异常，而poll返回null。如果移除头部的元素成功，则返回移除的元素。

- （3）同理，检测（Examine）元素的动作，返回头部元素（最开始加入的元素），但不删除元素， 如果队列为空，则element()方法抛异常，而peek()返回false。

- （4）Queue接口没有定义阻塞队列的方法，这些方法在BlockQueue接口中定义了。
- （5）Queue实现类通常不允许插入null元素，尽管一些实现类比如LinkedList不禁止插入null，但是还是不建议插入null，因为null也被用在poll方法的特殊返回值，以说明队列不包含元素。

## 四、双端队列Deque接口

![双端队列Deque](http://cdn.jayh.club/blog/20200906/jUTR0N36tMhV.png?imageslim)

**（1）Deque概念：**支持两端元素插入和移除的线性集合。名称`deque`是双端队列的缩写，通常发音为`deck`。大多数实现Deque的类，对它们包含的元素的数量没有固定的限制的，支持有界和无界。

**（2）Deque方法说明：**

![Deque方法](http://cdn.jayh.club/blog/20200906/Ck085QkBTTbQ.png?imageslim)

**说明： **

- 该列表包含包含访问deque两端元素的方法，提供了插入，移除和检查元素的方法。

- 这些方法种的每一种都存在两种形式：如果操作失败，则会抛出异常，另一种方法返回一个特殊值（null或false，取决于具体操作）。
- 插入操作的后一种形式专门设计用于容量限制的Deque实现，大多数实现中，插入操作不能失败，所以可以用插入操作的后一种形式。
- Deque接口扩展了Queue接口，当使用deque作为队列时，作为FIFO。元素将添加到deque的末尾，并从头开始删除。
- 作为FIFO时等价于Queue的方法如下表所示：

<img src="http://cdn.jayh.club/blog/20200906/QXj5EVYGGuqM.png?imageslim" alt="Deque等价于Queue的方法" style="zoom:80%;" />

比如Queue的add方法和Deque的addLast方法等价。

- Deque也可以用作LIFO（后进先出）栈，这个接口优于传统的Stack类。当作为栈使用时，元素被push到deque队列的头，而pop也是从队列的头pop出来。

- Stack（栈）的方法正好等同于Deque的如下方法：

  <img src="http://cdn.jayh.club/blog/20200906/Vy281TE6Hvzo.png?imageslim" alt="Dque等价于Stack的方法" style="zoom:80%;" />

注意：peek方法不论是作为栈还是队列，都是从队列的检测队列的头，返回最先加入的元素。比如第一次put 100，第二次put 200，则peek返回的是100。如下图所示：

![mark](http://cdn.jayh.club/blog/20200906/8w6fOGdR0uVo.png?imageslim)

## 五、队列骨架 AbstractQueue抽象类

AbstractQueue是一个抽象类，继承了Queue接口，提供了一些Queue操作的骨架实现。

![mark](http://cdn.jayh.club/blog/20200906/cteW1VQU8q8p.png?imageslim)

方法add、remove、element方法基于offer、poll和peek。也就是说如果不能正常操作，则抛出异常。我们来看下AbstactQueue是怎么做到的。

- AbstractQueue的add方法

```java
public boolean add(E e) {
    if (offer(e))
        return true;
    else
        throw new IllegalStateException("Queue full");
}
```

- AbstractQueue的remove方法

```java
public E remove() {
    E x = poll();
    if (x != null)
        return x;
    else
        throw new NoSuchElementException();
}
```

- AbstractQueue的element方法

```java
public E element() {
    E x = peek();
    if (x != null)
        return x;
    else
        throw new NoSuchElementException();
}
```

如果继承抽象类则必须保证offer方法不允许null值插入。



## 四、BlockingQueue

### 3.1 宏观来看BlockingQueue（阻塞队列）

![阻塞队列](http://cdn.jayh.club/blog/20200906/K8rc4tWINGSl.png?imageslim)

（1）BlockingQueue（阻塞队列）也是一种队列，支持两个附加操作的队列。

（2）这两个附加操作都支持阻塞的插入和移除方法。

（3）阻塞的插入：当队列满时，队列会阻塞插入元素的线程，直到队列不满。

（4）阻塞的移除：当队列为空，获取元素的线程会等待队列变为非空。

（5）应用场景：生产者和消费者，生产者线程向队列里添加元素，消费者线程从队列里移除元素，阻塞队列时获取和存放元素的容器。

（6）为什么要用阻塞队列：生产者生产和消费者消费的速率不一样，需要用队列来解决速率差问题，当队列满了或空的时候，则需要阻塞生产或消费动作来解决队列满或空的问题。

（7）Java中的阻塞队列有7个，都继承BlockingQueue接口：

- ArrayBlockingQueue 由数组构成的有界阻塞队列
- LinkedBlockingQueue 由链表构成的有界阻塞队列，界限默认大小为Integer.MAX_Value（21亿），值非常大，相当于无界。
- LinkedBlockingDeque 由链表构成的双向阻塞队列
- LinkedTransferQueue 由链表构成的无界阻塞队列
- SynchronousQueue 不存储元素的阻塞队列，只做数据传递
- LinkedTransferQueue 由链表构成的无界阻塞TransferQueue队列
- DelayQueue 使用优先级队列实现的延迟无界阻塞队列

### 3.2 案例解析

线程A往阻塞队列（Blocking Queue）中`添加`元素，而线程B从阻塞队列中`移除`元素。

- **当阻塞队列为空的时候** （一个元素都没有），则从队列中获取元素的操作将会被阻塞。
  - 生活中的案例：去海底捞吃火锅的时候，早上8点没人来吃火锅，所以需要等客人过来。
  - 翻译成线程：现在没有元素需要添加，而且阻塞队列为空，所以线程B不需要从队列中拿元素出来，所以线程B获取元素的操作被阻塞了。
- **当阻塞队列满了的时候** （所有位置都放有元素），则从队列中添加元素的操作将会被阻塞。
  - 生活中的案例：去海底捞吃火锅的时候，人太多了，需要排号，等其他桌空出来了才能进去。
  - 翻译成线程：线程A往阻塞队列中添加元素，将队列填满了，线程B现在正在忙，无法拿出队列中的元素，所以阻塞队列没有地方再放元素了，这个时候线程A添加元素的操作就被阻塞了

### 3.3 操刀BlockingQueue接口

**BlockingQueue接口的12个核心方法：** 

![BlockingQueue接口的12个核心方法](http://cdn.jayh.club/blog/20200906/jz9DxBDCqWya.png?imageslim)

有三大类操作：插入、移除、检查

- 插入有四种方法：add、offer、put、offer超时版。
  - add方法特别之处用于添加失败时抛出异常，共有四种异常：
    - IllegalStateException - 队列满了
    - ClassCastException - 添加的元素类型不匹配
    - NullPointerException - 添加的元素为null
    - IllegalArgumentException - 添加的元素某些属性不匹配
  - offer方法特别之处用于添加失败时只返回false
  - put方法特别之处用于当阻塞队列满时，生产者如果往队列里put元素，则队列会一直阻塞生产者线程，直到队列可用或者响应中断退出
  - offer超时方法特别之处用于当阻塞队列满时，生产者如果往队列里面插入元素，队列会阻塞生产者线程一段时间，如果超过了指定时间，生产者线程会退出，并返回false。
- 移除有四种方法：remove、poll、take、poll超时版
  - remove方法特别之处用于移除失败时抛出异常
    - NoSuchElementException - 如果这个队列是空的
  - poll方法特别之处用于移除失败时返回null
  - take方法特别之处用于当阻塞队列为空时，消费者线程如果从队列里面移除元素，则队列会一直阻塞消费者线程，直到队列不为空
  - poll超时方法特别之处用于当阻塞队列空时，消费者如果从队列里面删除元素，则队列会一直阻塞消费者线程，如果超过了指定时间，消费者线程会退出，并返回null
- 检查有两种方法：element、peek
  - element方法用于检测头部元素的存在性，如果队列为空，则抛出异常，否则返回头部元素。
  - peek方法用于检测头部元素的存在性，如果队列为空，返回特殊值null，否则返回头部的元素

## 四、ArrayBlockingQueue

## 五、LinkedBlockingQueue 

## 六、LinkedBlockingDeque 

## 七、LinkedTransferQueue 





