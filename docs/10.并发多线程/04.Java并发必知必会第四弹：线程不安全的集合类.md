# Java并发必知必会第四弹：用积木讲解List | 源码解析

![封面图](http://cdn.jayh.club/blog/20200828/084338941.png)

本篇主要内容如下



本篇所有示例代码已更新到[Github](https://github.com/Jackson0714/PassJava-Learning)

本篇文章已收纳到我的[Java在线文档](www.jayh.club)

**《Java并发必知必会》系列：**

[1.反制面试官 | 14张原理图 | 再也不怕被问 volatile!](https://juejin.im/post/6861885337568804871)

[2.程序员深夜惨遭老婆鄙视，原因竟是CAS原理太简单？](https://juejin.im/post/6863799243182702599)

[3.用积木讲解ABA原理 | 老婆居然又听懂了！](https://juejin.im/post/6864945088721027079)

![集合，准备团战](http://cdn.jayh.club/blog/20200828/U30tj9w8Yybo.gif)

## 一、线程不安全之ArrayList

**集合框架**有Map和Collection两大类，Collection下面有List、Set、Queue。List下面有ArrayList、Vector、LinkedList。如下图所示：

![集合框架思维导图](http://cdn.jayh.club/blog/20200828/162802050.png)

**JUC并发包**下的集合类Collections有Queue、CopyOnWriteArrayList、CopyOnWriteArraySet、ConcurrentMap

![JUC包下的Collections](http://cdn.jayh.club/blog/20200828/162129623.png)



### 1.1、ArrayList的底层初始化操作

首先我们来复习下ArrayList的使用，下面是初始化一个ArrayList，数组存放的是Integer类型的值。

``` java
new ArrayList<Integer>();
```

那么底层做了什么操作呢？

### 1.2、ArrayList的底层原理

#### 1.2.1 初始化数组

```java
/**
 * Constructs an empty list with an initial capacity of ten.
 */
public ArrayList() {
    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
}
```

创建了一个空数组。

### 1.2.1 ArrayList的add操作

```java
public boolean add(E e) {
    ensureCapacityInternal(size + 1);  // Increments modCount!!
    elementData[size++] = e;
    return true;
}
```

重点是这一步：elementData[size++] = e; size++和elementData[xx]=e，这两个操作都不是`原子操作`（不可分割的一个或一系列操作，要么都成功执行，要么都不执行）。

#### 1.2.2 ArrayList扩容源码解析

（1）执行add操作时，会先确认是否超过数组大小

```java
ensureCapacityInternal(size + 1);
```

![ensureCapacityInternal方法](http://cdn.jayh.club/blog/20200828/103253283.png)

（2）计算数组的当前容量calculateCapacity

```java
private void ensureCapacityInternal(int minCapacity) {
    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));
}
```

`minCapacity` : 值为1

`elementData`：代表当前数组

我们先看ensureCapacityInternal调用的ensureCapacityInternal方法

```java
calculateCapacity(elementData, minCapacity)
```

calculateCapacity方法如下：

```java
private static int calculateCapacity(Object[] elementData, int minCapacity) {
    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
        return Math.max(DEFAULT_CAPACITY, minCapacity);
    }
    return minCapacity;
}
```

`elementData`：代表当前数组，添加第一个元素时，elementData等于DEFAULTCAPACITY_EMPTY_ELEMENTDATA（空数组）

`minCapacity`：等于1

`DEFAULT_CAPACITY`： 等于10

返回 Math.max(DEFAULT_CAPACITY, minCapacity) = 10

所以第一次添加元素时，计算数组的大小为10

（3）确定当前容量ensureExplicitCapacity

![ensureExplicitCapacity方法](http://cdn.jayh.club/blog/20200828/110617457.png)

minCapacity = 10

elementData.length=0

因minCapacity > elementData.length，所以进行第一次扩容，调用grow()方法从0扩大到10。

（4）调用grow方法

![grow方法](http://cdn.jayh.club/blog/20200828/111339453.png)

oldCapacity=0，newCapacity=10。

然后执行 elementData = Arrays.copyOf(elementData, newCapacity);

将当前数组和容量大小进行数组拷贝操作，赋值给elementData。**数组的容量设置为10**

elementData的值和DEFAULTCAPACITY_EMPTY_ELEMENTDATA的值将会不一样。

（5）然后将元素赋值给数组第一个元素，且size自增1

``` java
elementData[size++] = e;
```

（6）添加第二个元素时，传给ensureCapacityInternal的是2

```
ensureCapacityInternal(size + 1)
```

size=1，size+1=2

（7）第二次添加元素时，执行calculateCapacity

![mark](http://cdn.jayh.club/blog/20200828/112454671.png)

elementData的值和DEFAULTCAPACITY_EMPTY_ELEMENTDATA的值不相等，所以直接返回2

（8）第二次添加元素时，执行ensureExplicitCapacity

因minCapacity等于2，小于当前数组的长度10，所以不进行扩容，不执行grow方法。

![mark](http://cdn.jayh.club/blog/20200828/112704893.png)

（9）将第二个元素添加到数组中，size自增1

```
elementData[size++] = e
```

（10）当添加第11个元素时调用grow方法进行扩容

![mark](http://cdn.jayh.club/blog/20200828/120912599.png)

minCapacity=11， elementData.length=10，调用grow方法。

`（11）扩容1.5倍`

```java
int newCapacity = oldCapacity + (oldCapacity >> 1);
```

oldCapacity=10，先换算成二级制1010，然后右移一位，变成0101，对应十进制5，所以newCapacity=10+5=15，扩容1.5倍后是15。

![扩容1.5倍](http://cdn.jayh.club/blog/20200828/121108727.png)

。

（12）小结

- 1.ArrayList初始化为一个`空数组`

- 2.ArrayList添加第一个元素时，数组的容量设置为`10`

- 3.当ArrayList数组超过当前容量时，扩容至`1.5倍`（遇到计算结果为小数的，向下取整），第一次扩容后，容量为15，第二次扩容至22...

- 4.ArrayList在第一次和扩容后都会对数组进行拷贝`Arrays.copyOf`

### 1.3、ArrayList单线程环境是否安全？

**场景：**

我们通过一个`添加积木的例子`来说明单线程下ArrayList是线程安全的。

将 积木 `三角形A`、`四边形B`、`五边形C`、`六边形D`、`五角星E`依次添加到一个盒子中，盒子中共有5个方格，每一个方格可以放一个积木。

![ArrayList单线程下添加元素](http://cdn.jayh.club/blog/20200827/150707103.png)

**代码实现：**

（1）这次我们用新的积木类`BuildingBlockWithName`

这个积木类可以传形状shape和名字name

```java
/**
 * 积木类
 * @author: 悟空聊架构
 * @create: 2020-08-27
 */
class BuildingBlockWithName {
    String shape;
    String name;
    public BuildingBlockWithName(String shape, String name) {
        this.shape = shape;
        this.name = name;
    }
    @Override
    public String toString() {
        return "BuildingBlockWithName{" + "shape='" + shape + ",name=" + name +'}';
    }
}
```

（2）初始化一个ArrayList

```java
ArrayList<BuildingBlock> arrayList = new ArrayList<>();
```

（3）依次添加三角形A、四边形B、五边形C、六边形D、五角星E

```java
arrayList.add(new BuildingBlockWithName("三角形", "A"));
arrayList.add(new BuildingBlockWithName("四边形", "B"));
arrayList.add(new BuildingBlockWithName("五边形", "C"));
arrayList.add(new BuildingBlockWithName("六边形", "D"));
arrayList.add(new BuildingBlockWithName("五角星", "E"));
```

（4）验证`arrayList`中元素的内容和顺序是否和添加的一致

``` java
BuildingBlockWithName{shape='三角形,name=A}
BuildingBlockWithName{shape='四边形,name=B}
BuildingBlockWithName{shape='五边形,name=C}
BuildingBlockWithName{shape='六边形,name=D}
BuildingBlockWithName{shape='五角星,name=E}
```

我们看到结果确实是一致的。

**小结：**单线程环境中，ArrayList是线程安全的。

### 1.4、多线程下ArrayList是不安全的

**场景如下：**20个线程随机往ArrayList添加一个任意形状的积木。

![多线程场景往数组存放元素](http://cdn.jayh.club/blog/20200828/084338941.png)

（1）代码实现：20个线程往数组中随机存放一个积木。

![多线程下ArrayList是不安全的](http://cdn.jayh.club/blog/20200827/154511673.png)

（2）打印结果：程序开始运行后，每个线程只存放一个随机的积木。

![打印结果](http://cdn.jayh.club/blog/20200827/172244687.png)

数组中会不断存放积木，多个线程会争抢数组的存放资格，在存放过程中，会抛出一个异常: 	`ConcurrentModificationException`（并行更新异常）

``` java
Exception in thread "10" Exception in thread "13" java.util.ConcurrentModificationException
```

![mark](http://cdn.jayh.club/blog/20200827/172451907.png)

这个就是常见的并发异常：java.util.ConcurrentModificationException

### 1.5 那如何解决ArrayList线程不安全问题呢？

有如下方案：

- 1.用Vector代替ArrayList
- 2.用Collections.synchronized()
- 3.CopyOnWriteArrayList

### 1.6 Vector保证线程安全

下面就来分析vector的源码。

#### 1.6.1 初始化Vector

初始化容量为10

```java
public Vector() {
    this(10);
}
```

#### 1.6.2 Add操作是线程安全的

Add方法加了synchronized，来保证add操作是线程安全的（保证可见性、原子性、有序性），对这几个概念有不懂的可以看下之前的写的文章-》 [反制面试官 | 14张原理图 | 再也不怕被问 volatile!](https://juejin.im/post/6861885337568804871)

![Add方法加了synchronized](http://cdn.jayh.club/blog/20200828/173019097.png)

#### 1.6.3 Vector扩容至2倍

```
int newCapacity = oldCapacity + ((capacityIncrement > 0) ? capacityIncrement : oldCapacity);
```

![容量扩容至2倍](http://cdn.jayh.club/blog/20200828/171023634.png)

**注意：**capacityIncrement 在初始化的时候可以传值，不传则默认为0。如果传了，则第一次扩容时为设置的oldCapacity+capacityIncrement，第二次扩容时扩大1倍。

缺点：虽然保证了线程安全，但因为加了排斥锁synchronized，所以性能降低。

![阻塞](http://cdn.jayh.club/blog/20200828/jUTSwB8cAuRs.png?imageslim)

#### 1.6.4 用积木模拟CopyOnWriteArrayList的add操作

![vector的add操作](http://cdn.jayh.club/blog/20200828/175709345.png)

当往vector存放元素时，给盒子加了一个锁，只有一个人可以存放积木，放完后，释放锁，放第二元素时，再进行加锁，依次往复进行。

### 1.7 使用Collections.synchronizedList保证线程安全

我们可以使用Collections.synchronizedList方法来封装一个ArrayList。

```
List<Object> arrayList = Collections.synchronizedList(new ArrayList<>());
```

为什么这样封装后，就是线程安全的？

**源码解析：**因为Collections.synchronizedList封装后的list，list的所有操作方法都是带`synchronized`关键字的（除iterator()之外），相当于所有操作都会进行加锁，所以使用它是线程安全的（除迭代数组之外）。

![加锁](http://cdn.jayh.club/blog/20200828/Nm0SXSoQvCfC.png?imageslim)

![mark](http://cdn.jayh.club/blog/20200828/QO9wUIByis9W.png?imageslim)

**注意：**当迭代数组时，需要手动做同步。官方示例如下：

```java
synchronized (list) {
     Iterator i = list.iterator(); // Must be in synchronized block
     while (i.hasNext())
         foo(i.next());
}
```

### 1.8 使用CopyOnWriteArrayList保证线程安全

![复制](http://cdn.jayh.club/blog/20200828/1YkJT4tlYzow.png?imageslim)



#### 1.8.1 CopyOnWriteArrayList思想

- Copy on write：写时复制，一种读写分离的思想。
- 写操作：添加元素时，不直接往当前容器添加，而是先拷贝一份数组，在新的数组中添加元素后，在将原容器的引用指向新的容器。因为数组时用volatile关键字修饰的，所以当array重新赋值后，其他线程可以立即知道（volatile的可见性）
- 读操作：读取数组时，读老的数组，不需要加锁。
- 读写分离：写是copy了一份新的数组，读是读老的数组，所以是读写分离。

#### 1.8.2 使用方式

```java
CopyOnWriteArrayList<BuildingBlockWithName> arrayList = new CopyOnWriteArrayList<>();
```

#### 1.8.3 底层源码分析

![CopyOnWriteArrayList的add方法分析](http://cdn.jayh.club/blog/20200828/axPEk62UvBTN.png?imageslim)



- 先定义了一个可重入锁 `ReentrantLock`
- 添加元素前，先获取锁`lock.lock()`
- 添加元素时，先拷贝当前数组 `Arrays.copyOf`
- 添加元素时，扩容+1（`len + 1`）
- 添加元素后，将数组引用指向新加了元素后的数组`setArray(newElements)`

为什么数组重新赋值后，其他线程可以立即知道？

因为这里的数组是用volatile修饰的，`哇，又是volatile`，这个关键字真妙^_^

![妙啊](http://cdn.jayh.club/blog/20200828/9GzmvnjuBe5V.gif)

## 二、线程不安全之Set