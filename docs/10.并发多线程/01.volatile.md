# 万字长文 | 我想跟你聊一宿的Java volatile | 附示例

# 一、Volatile怎么念？

看到这个单词一直不知道怎么发音

```sh
英 [ˈvɒlətaɪl]  美 [ˈvɑːlətl]

adj. [化学] 挥发性的；不稳定的；爆炸性的；反复无常的
```

那Java中Volatile又是干啥的呢？

# 二、Java中Volatile用来干啥？

- Volatile是Java虚拟机提供的`轻量级`的同步机制（三大特性）
  - 保证可见性
  - 不保证原子性
  - 禁止指令重排

要理解三大特性，就必须知道Java内存模型（JMM），那JMM又是什么呢？

# 三、JMM又是啥？

![Java内存模型](http://cdn.jayh.club/blog/20200812/154932124.png)

## 3.1 为什么需要Java内存模型？

> `Why`:屏蔽各种硬件和操作系统的内存访问差异

JMM是Java内存模型，也就是Java Memory Model，简称JMM，本身是一种抽象的概念，实际上并不存在，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式。

## 3.2 到底什么是Java内存模型？

- 1.定义程序中各种变量的访问规则
- 2.把变量值存储到内存的底层细节
- 3.从内存中取出变量值的底层细节

## 3.3 Java内存模型的两大内存是啥？

- 主内存
  - Java堆中对象实例数据部分
  - 对应于物理硬件的内存
- 工作内存
  - Java栈中的部分区域
  - 优先存储于寄存器和高速缓存

## 3.4 Java内存模型是怎么做的？

Java内存模型的几个规范：

- 1.所有变量存储在主内存

- 2.主内存是虚拟机内存的一部分

- 3.每条线程有自己的工作内存

- 4.线程的工作内存保存变量的主内存副本

- 5.线程对变量的操作必须在工作内存中进行
- 6.不同线程之间无法直接访问对方工作内存中的变量
- 7.线程间变量值的传递均需要通过主内存来完成

由于JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存（有些地方称为栈空间），工作内存是每个线程的私有数据区域，而Java内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，`但线程对变量的操作（读取赋值等）必须在工作内存中进行，首先要将变量从主内存拷贝到自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写会主内存`，不能直接操作主内存中的变量，各个线程中的工作内存中存储着主内存中的变量副本拷贝，因此不同的线程间无法访问对方的工作内存，线程间的通信（传值）必须通过主内存来完成，其简要访问过程：

![Java内存模型](http://cdn.jayh.club/blog/20200812/141310523.png)

## 3.5 Java内存模型的三大特性

- 可见性（当一个线程修改了共享变量的值时，其他线程能够立即得知这个修改）
- 原子性（一个操作或一系列操作是不可分割的，要么都执行，要么都不执行）
- 有序性（变量赋值操作的顺序与程序代码中的执行顺序一致）

关于有序性：如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。前半句是指“线程内似表现为串行的语义”（Within-Thread As-If-Serial Semantics），后半句是指“指令重排序”现象和“工作内存与主内存同步延迟”现象。

# 四、能给个示例说下怎么用volatile的吗？

考虑一下这种场景：

> 有一个对象的字段`number`初始化值=0，另外这个对象有一个公共方法`setNumberTo100()`可以设置number = 100，当主线程通过子线程来调用`setNumberTo100()`后，主线程是否知道number值变了呢？
>
> 答案：如果没有使用volatile来定义number变量，则主线程不知道子线程更新了number的值。

（1）定义如上述所说的对象：`ShareData`

``` java
class ShareData {
    int number = 0;

    public void setNumberTo100() {
        this.number = 100;
    }
}
```

（2）主线程中初始化一个子线程，名字叫做`子线程`

子线程先休眠3s，然后设置number=100。主线程不断检测的number值是否等于0，如果不等于0，则退出主线程。

```java
public class volatileVisibility {
    public static void main(String[] args) {
        // 资源类
        ShareData shareData = new ShareData();

        // 子线程 实现了Runnable接口的，lambda表达式
        new Thread(() -> {

            System.out.println(Thread.currentThread().getName() + "\t come in");

            // 线程睡眠3秒，假设在进行运算
            try {
                TimeUnit.SECONDS.sleep(3);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            // 修改number的值
            myData.setNumberTo100();

            // 输出修改后的值
            System.out.println(Thread.currentThread().getName() + "\t update number value:" + myData.number);

        }, "子线程").start();

        while(myData.number == 0) {
            // main线程就一直在这里等待循环，直到number的值不等于零
        }

        // 按道理这个值是不可能打印出来的，因为主线程运行的时候，number的值为0，所以一直在循环
        // 如果能输出这句话，说明子线程在睡眠3秒后，更新的number的值，重新写入到主内存，并被main线程感知到了
        System.out.println(Thread.currentThread().getName() + "\t 主线程感知到了 number 不等于 0");

        /**
         * 最后输出结果：
         * 子线程     come in
         * 子线程     update number value:100
         * 最后线程没有停止，并行没有输出"主线程知道了 number 不等于0"这句话，说明没有用volatile修饰的变量，变量的更新是不可见的
         */
    }
}
```

![没有使用volatile](http://cdn.jayh.club/blog/20200812/pjFzpO0940kR.png?imageslim)

（3）我们用volatile修饰变量number

```
class ShareData {
    //volatile 修饰的关键字，是为了增加多个线程之间的可见性，只要有一个线程修改了内存中的值，其它线程也能马上感知
    volatile int number = 0;

    public void setNumberTo100() {
        this.number = 100;
    }
}
```

输出结果：

``` sh
子线程	 come in
子线程	 update number value:100
main	 主线程知道了 number 不等于 0

Process finished with exit code 0
```

![mark](http://cdn.jayh.club/blog/20200812/L0Iey883RrF1.png?imageslim)



**小结：说明用volatile修饰的变量，当某线程更新变量后，其他线程也能感知到。**

# 五、volatile什么场景下会用到？

奇怪的是，volatile都不保证原子性，为啥我们还要用它？

volatile是轻量级的同步机制，对性能的影响比synchorized小。

> 典型的用法：检查某个状态标记以判断是否退出循环。

比如线程试图通过类似于数绵羊的传统方法进入休眠状态，为了使这个示例能正确执行，asleep必须为volatile变量。否则，当asleep被另一个线程修改时，执行判断的线程却发现不了。

**那为什么我们不直接用synchorized，lock锁？它们既可以保证可见性，又可以保证原子性为何不用呢？**

因为synchorized和lock是排他锁（悲观锁），如果有多个线程需要访问这个变量，将会发生竞争，只有一个线程可以访问这个变量，其他线程被阻塞了，会影响程序的性能。

> 注意：当且仅当满足以下所有条件时，才应该用volatile变量
>
> - 对变量的写入操作不依赖变量的当前值，或者你能确保只有单个线程更新变量的值。
> - 该变量不会与其他的状态一起纳入不变性条件中。
> - 在访问变量不需要加锁。

# 六、主线程是如何立即感知到变量变了呢？





















